集合总结:
参考:https://www.cnblogs.com/znn93/p/9366242.html
1.ArrayList和LinkedList有何区别？
ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。
（1）.ArrayList底层是数组,LinkedList底层是链表
 (2). ArrayList查询快,增删慢;LinkedList查询慢,增删快;
（3） LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。

2.HashMap和HashTable有何不同？
1).两者最主要的区别在于HashMap是非线程安全的,Hashtable是线程安全 
  Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是Collections.synchronizedMap()方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它Collections.synchronizedXX方法也是类似原理）
2).HashMap可以使用null作为key，而Hashtable则不允许null作为key
3).HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类
4).HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75
HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1
5).HashMap和Hashtable的底层实现都是数组+链表结构实现


3.HashMap实现原理
1).JDK1.7中HashMap底层结构是数组+链表组成,JDK1.8中,HashMap底层结构是数组+链表/红黑二叉树
2).利用key的hashCode重新hash计算出当前对象的元素在数组中的下标
3).通过put()和get()方法储存和获取对象。
put: 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；
      (2)如果key不同（出现冲突），则将当前的key-value放入链表中
get: 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。

HashMap是如何解决hash冲突的问题？
   核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中
做进一步的对比。


5.ConcurrentHashMap和HashMap的区别?
1).ConcurrentHashMap是线程安全的,HashMap是非线程安全的。
2).HashMap的key允许有null值，但是ConCurrentHashMap不允许。
3).底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表实现，
                  JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。

Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，
链表则是主要为了解决哈希冲突而存在的；
实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁
容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率
提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 
synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8
中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，
效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用
put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

6.HashSet和HashMap、Hashtable的区别
HashSet不是key value结构，仅仅是存储不重复的元素，相当于简化版的HashMap，
HashSet内部就是使用HashMap实现得,HashSet也是非线程安全的。
 

7.分别理解hashMap、hashTable、ConcurrentHashMap的底层实现原理?
参考:https://www.cnblogs.com/heyonggang/p/9112731.html

8.哪些集合类是线程安全的？
	Vector、HashTable、ConcurrentHashMap是线程安全的，可以在多线程环境下使用。
Java1.5并发API包括一些集合类，允许迭代时修改，
因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。

9.如何决定选用HashMap还是TreeMap？
对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的
key集合进行遍历，TreeMap是更好的选择。
基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。


数据结构:
参考: http://www.bjpowernode.com/javazixun/3137.html
1.java内存模型是什么?
java内存模型分两种：gc内存模型,并发内存模型。
gc内存模型分为三部分：栈，堆，程序计数器
即:虚拟机栈、本地方法栈、方法区、堆、程序计数器
并发内存模型:分为主内存和工作内存
所有变量都存贮到主内存（如虚拟机物理内存中的一部分）中,
线程中的工作内存保存了该线程使用到的变量的主内存的副本拷贝。

2.jvm内存模型是什么?
虚拟机栈、本地方法栈、方法区、堆、程序计数器

3.队列和栈是什么，列出它们的区别？
栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。
队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。
栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。
Stack是一

栈:  后进先出（LIFO） --》允许对元素进行后进先出（LIFO）进行检索
队列:先进先出（FIFO）检索元素

4.java中的堆和栈分别是什么数据结构，为什么要分为堆和栈来存储数据？

栈是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。
堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，
   是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。
   由于堆的这个特性，常用来实现优先队列，堆的存取是随意的。

为什么要划分堆和栈：

1）从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。

2）堆与栈的分离，使得堆中的内容可以被多个栈共享。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。

3）栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。

4）体现了Java面向对象这一核心特点（也可以继续说一些自己的理解）。

5.其它面试题:参考: http://www.bjpowernode.com/javazixun/3137.html

垃圾回收机制总结:
1.GC的作用：
1).分配内存
2).确保被引用对象的内存不被错误的回收
3).回收不再被引用的对象的内存空间

2.哪些内存需要回收？ 
	JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。
其中程序计数器、虚拟机栈、本地方法栈3个区域随线程
而生、随线程而灭!所以堆区和方法区的内存需要被回收!

3.垃圾回收机制的主要解决问题
1).哪些内存需要回收？
2).什么时候回收？
3).如何回收？

4.判断对象是否存活的算法?
判断方法：
1).引用计数算法
每当一个地方引用它时，计数器+1；引用失效时，计数器-1；计数值=0——不可能再被引用。
查看运行结果，会发现并没有因为两个对象互相引用就没有回收，因此引用计数算法很难解决
对象之间相互矛盾循环引用的问题。
2).可达性分析算法：
向图，树图，把一系列“GC Roots”作为起始点，从节点向下搜索，路径称为引用链，当一个对象
到GC Roots没有任何引用链相连，即不可达时，则证明此对象时不可用的。


4.什么时候回收？
当对象不可达且对象没有覆盖finalize()方法或者finalize()方法没有被调用过。

即使是被判断不可达的对象，也要再进行筛选，当对象没有覆盖finalize()方法，或者finalize
方法已经被虚拟机调用过，则没有必要执行；
如果有必要执行——放置在F-Queue的队列中——Finalizer线程执行。
注意：对象可以在被GC时可以自我拯救（this），机会只有一次，因为任何一个对象的finalize()
方法都只会被系统自动调用一次。并不建议使用，应该避免。使用try_finaly或者其他方式。

5.常用的垃圾收集算法 
5.1) 标记-清除算法?
	标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图
所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不
存活的对象，因此会造成内存碎片。

5.2) 复制算法
	复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集合（GC Roots）中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。

5.3) 标记-整理算法(Mark-compact) 
     标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端
空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。

5.4) 分代收集算法
    分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下
将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代
的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点
采取最适合的收集算法。

6.常见的垃圾收集器 ?
引用计数器和跟踪计数器两种。
引用计数器记录对象是否被引用，当计数器为零时，说明对象已经不再被使用，可以进行回收。
           java中的对象有复杂的引用关系，不是很适合引用计数器，所以sun jdk中并没有实现这种GC方式。
跟踪收集器，全局记录数据的引用状态，基于一定的条件触发。执行的时候，从根集合开始扫描对象的
           引用关系，主要有复制（copying）、标记-清除（Mark-Sweep）、标记-压缩(Mark-Compact)那种算法。

7.垃圾回收流程
1)、新建的对象，大部分存储在Eden中
2)、当Eden内存不够，就进行Minor GC释放掉不活跃对象；
    然后将部分活跃对象复制到Survivor中（如Survivor1），同时清空Eden区
3)、当Eden区再次满了，将Survivor1中不能清空的对象存放到另一个Survivor2中，
    同时将Eden区中的不能清空的对象，复制到Survivor1，同时清空Eden区
4)、重复多次（默认15次）：Survivor中没有被清理的对象就会复制到老年区（Old）
5)、当Old达到一定比例，则会触发Major GC释放老年代
6)、当Old区满了，则触发一个一次完整的垃圾回收（Full GC）
7)、如果内存还是不够，JVM会抛出OOM异常。

8.java垃圾回收机制: 
垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个
单独的低级别的线程运行，不可预知的情况下对堆内存中已经死亡的或者长时间没有使用的对象
进行清除和回收，程序员不需要实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 

【回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。
垃圾回收机制 垃圾收集是将分配给对象但不再使用的内存回收或释放的过程。如果一个对象
没有指向它的引用或者其赋值为null,则次对象适合进行垃圾回收,垃圾回收机以低优先级运行 
检查不被使用和指向的对象并把它删除。】

9.内存溢出么原因有哪些？解决方法
常见的有以下几种：
1).内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
2).集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收；
3).代码中存在死循环或循环产生过多重复的对象实体；
4).启动参数内存值设定的过小;
5).使用的第三方软件中的 BUG；

10.内存溢出的解决方案：
1).第一步，修改 JVM 启动参数，直接增加内存。(-Xms，-Xmx 参数一定不要忘记加。)
2).第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
3).第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
4).第四步，使用内存查看工具动态查看内存使用情况。

11.jvm面试题:https://www.cnblogs.com/JiHC/p/12852759.html
参考:https://www.icode9.com/content-4-395454.html
https://www.cnblogs.com/shoshana-kong/p/10571976.html

12.说一下类加载的执行过程？

类加载分为以下 5 个步骤：

加载：加载class文件
检查：检查加载的 class 文件的正确性；
准备：给类中的静态变量分配内存空间；
解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；
初始化：对静态变量和静态代码块执行初始化工作。

13.说一下 jvm 调优的工具？

JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 
和 jvisualvm 这两款视图监控工具。
1).jconsole：用于对JVM 中的内存、线程和类等进行监控；
2).jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、
gc 变化等。
jvm调优工具检测:https://www.cnblogs.com/ityouknow/p/6437037.html


14.jvm性能优化:https://www.cnblogs.com/mxb0611/p/12081726.html

15.常用的 jvm 调优的参数都有哪些？
-Xms2g：初始化推大小为 2g；

-Xmx2g：堆最大内存为 2g；

-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；

-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；

–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；

-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；

-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；

-XX:+PrintGC：开启打印 gc 信息；

-XX:+PrintGCDetails：打印 gc 详细信息。

16.关于CMS垃圾回收机制？
	采用CMS时候，新生代必须使用Serial GC或者ParNew GC两种。CMS共有七个步骤，只有Initial Marking和Final Marking两个阶段
是stop-the-world的，其他步骤均和应用并行进行。持久代的GC也采用CMS，通过-XX：CMSPermGenSweepingEnabled 
-XX：CMSClassUnloadingEnabled来制定。在采用cms gc的情况下，ygc变慢的原因通常是由于old gen出现了大量的碎片。
    
17.JVM的悲观策略是啥？
所谓的悲观策略（http://tmalltesting.com/archives/663 我们性能测试团队一个同学分析的案例），就是
JVM不按照JVM指定的参数来进行CMS GC，
而是根据内存情况以及之前回收的方式动态调整，自行进行GC。旧生代剩余的空间（available）大
于新生代中使用的空间（max_promotion_in_bytes），
或者大于之前平均晋升的old的大小（av_promo），返回false。cms gc是每隔一个周期（默认2s）就会做一次
这个检查，如果为false，则不执行YGC，
而触发cms gc。
	
18.JVM的乐观锁策略是啥? 
  乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数
据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候
会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果
失败则要重复读-比较-写的操作。java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。

多线程总结:
1.Java通过Executors提供四种线程池
1).CachedThreadPool()：可缓存线程池。
2).FixedThreadPool()：定长线程池。
3).ScheduledThreadPool()：定时线程池。
4).SingleThreadExecutor()：单线程化的线程池。
参考:https://blog.csdn.net/qq_29373285/article/details/85238728

2.线程池的实现原理
提交一个任务到线程池中，线程池的处理流程如下：
1)、判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程
   没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下
   个流程。
2)、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队
    列里。如果工作队列满了，则进入下个流程。
3)、判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。
如果已经满了，则交给饱和策略来处理这个任务。

3.线程池常用参数
corePoolSize：核心线程数量，会一直存在，除非allowCoreThreadTimeOut设置为true
maximumPoolSize：线程池允许的最大线程池数量
keepAliveTime：线程数量超过corePoolSize，空闲线程的最大超时时间
unit：超时时间的单位
workQueue：工作队列，保存未执行的Runnable 任务
threadFactory：创建线程的工厂类
handler：当线程已满，工作队列也满了的时候，会被调用。被用来实现各种拒绝策略。

4. Java 实现线程有哪几种方式？
1) 继承 Thread 类实现多线程
2) 实现 Runnable 接口方式实现多线程
3) 使用 ExecutorService、Callable、Future 实现有返回结果的多线程
【1)：继承Thread
2)：实现 Runnable
3)：实现callable
  如果需要返回值使用callable，如果不需要返回最好使用runnable，因为继承只能单继承，
所以不推荐使用Thread。
】

5.同步有几种方式，分别是什么???
1).同步代码块:
即有synchronized(object){
}
注:同步是一种高开销的操作,因此应该尽量减少同步的内容。
通常没有必要同步整个方法,使用synchronized代码块同步关键代码即可。

2).同步方法:
即有synchronized关键字修饰的方法
由于java的每个对象都有一个内置锁,当用此关键字修饰方法时,内置锁会保护整个方法。在调用该方法前,需要获得内置锁,否则就处于阻塞状态。
代码如:
public synchronized void save(){}
注:synchronized关键字也可以修饰静态方法,此时如果调用该静态方法,将会锁住整个类。

6.什么是线程池？ 为什么要使用它???
在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。
从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，
每次处理一个任务；数目固定的线程池或者是缓存线程池(一个适合很多生存期短的任务的程序
的可扩展线程池)。

在程序启动的时候就创建若干线程来处理,它们被称为线程池,里面的线程叫工作线程。 
在程序启动的时候就创建若干线程来处理,他们被称为线程池,里面的线程叫工作线程。 

7.Java中synchronized 和 ReentrantLock 有什么不同？
	Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。
比如你不能扩展锁之外的方法或者块边界，尝试获取锁 时不能中
途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 
ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存
语义且它还具有可扩展性。

8.synchronized 关键字的用法？
答：synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，
可以用synchronized(对象) { … }定义同步代码块，
或者在声明方法时将 synchronized 作为方法的修饰符。在第60题的例子中已经展示了
synchronized 关键字的用法。

9.Synchronized和Violatile的本质区别？
1) Synchronized底层实现依赖于jvm的监视器monitor，对编译后的代码指令加锁。所以会出现阻塞情况。
  而Violatile底层实现则是借助于寄存器，也就是工作内存，在读取Violatile变量时，jvm会告诉寄存器，该变量的值需要同步到主内存，不会出现阻塞的情况。
2) 线程池安全主要涉及两个方面：原子性和可见性。Synchronized既可以保证原子性，也可以保证可见性。
   而Violatile只能保证可见性，所以会存在线程安全问题。
3) Synchronized的锁级别可以是变量，方法，和类。而Violatile只能是变量级别。

10.Java中synchronized 和 ReentrantLock 有什么不同？
1).Lock可以指定锁的起始位置和结束位置,synchronized只能锁代码块和方法。
2).lock需要调用unLock()去释放锁,synchronized会自动获取锁和释放锁。
   synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
  而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，
  因此使用Lock时需要在finally块中释放锁；
3).线程较多时,lock性能好;线程较少时,synchronized性能好。


11.线程的生命周期???
1).新建（new）：处于该状态的时间很短暂。已被分配了必须的系统资源，并执行了初始化。表示有资格获得CPU时间。调度器可以把该线程变为runnable或者blocked状态
2).就绪（Runnable）：这种状态下只要调度器把时间片分配给线程，线程就能运行。处在这种状态就是可运行可不运行的状态
3).阻塞（Bolocked）：线程能够运行，但有个条件阻止它的运行。当线程处于阻塞状态时，调度器将会忽略线程，不会分配给线程任何CPU时间（例如sleep）。只有重新进入了就绪状态，才有可能执行操作。
4).死亡（Dead）：处于死亡状态的线程讲不再是可调度的，并且再也不会得到CPU时间。任务死亡的通常方式是从run()方法返回。
一个任务进入阻塞状态，可能有如下原因：
1.sleep
2.wait()，知道线程得到了notify()或者notifyAll()消息，线程才会进入就绪状态。
3.任务在等待某个输入/输出完成
4.线程在试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。

12.如何避免死锁???
Java多线程中的死锁
	死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，
若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，
死锁的发生必须满足以下四个条件：

死锁发生的四个条件
避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。

13.Java多线程中调用wait() 和 sleep()方法有什么不同？
  Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时
它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。

14.Thread 类中的start() 和 run() 方法有什么区别？
这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部 
调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启 动，
start()方

15.java中的volatile关键字是什么作用?怎样使用它?在Java中它跟synchronized方法有什么不同?
	自从java5和java内存模型改变以后,基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎么样在并发环境
中确保可见性、顺序性和一致性。


16.synchronized 关键字的用法？
答：synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，
或者在声明方法时将 synchronized 作为方法的修饰符。在第60题的例子中已经展示了 synchronized 关键字的用法。

17.sleep() 和 yield() 有什么区别?
答：
① sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会；
② 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（ready）状态；
③ sleep() 方法声明抛出InterruptedException，而 yield() 方法没有声明任何异常；
④ sleep() 方法比 yield() 方法（跟操作系统相关）具有更好的可移植性。

18.同步方法和同步代码块的区别是什么？
在 Java 语言中，每一个对象有一把锁。
线程可以使用 synchronized 关键字来获取对象上的锁。 synchronized 关键字
可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。

多线程:
1.http://wiki.jikexueyuan.com/project/java-interview-bible/multi-thread.html
2.https://www.jianshu.com/p/45e77411cd2e
3.https://blog.51cto.com/13634103/2093133
4.https://blog.csdn.net/woshilijiuyi/article/details/81208117


java反射总结:
反射总结:
反射的实现原理：
1). 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；

2). 每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；

3). 反射也是考虑了线程安全的，放心使用；

4). 反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；

5). 反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；

6). 当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；

7). 调度反射方法，最终是由jvm执行invoke0()执行；

1.Java反射的主要功能：
1).确定一个对象的类
2).取出类的modifiers,数据成员,方法,构造器,和超类.
3).找出某个接口里定义的常量和方法说明.
4).创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).
5).取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.
6).在运行时刻调用动态对象的方法.
7).创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.

2.反射的应用很多，很多框架都有用到
2.1) spring 的 ioc/di 也是反射….
2.2) javaBean和jsp之间调用也是反射….
2.3) struts的 FormBean 和页面之间…也是通过反射调用….
2.4) JDBC 的 classForName()也是反射…..
2.5) hibernate的 find(Class clazz) 也是反射….
2.6) 反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣。怎么使用使你的系统达到最优就看你系统架构和综合使用问题啦，这里就不多说了。

3.反射机制的优缺点？
静态编译：在编译时确定类型，绑定对象，即通过
动态编译：运行时确定类型，绑定对象。动态编译最大限度的发挥了java的灵活性，体现了多态的应用，
有利于降低类之间的耦合性。

4.请描述一下类加载机制，然后说明一下什么是反射机制，以及反射的常见调用方式。
类加载机制：java源文件经过编译后产生一个字节码文件。Java虚拟机把描述类的数据加载到内存中，对数据进行处理后成为一个对象实例，而这个对象为Class类的实例。
反射机制：运行时加载，使用编译器未知的类获取其中完整构造并生成对象的实体或对其设值调用其中的方法。
常见调用方式：Class.forName()静态方法，可以利用类名在CLASSPATH中查找对应的类，并且装载到内存，返回这个class。
              加载类的过程采用懒惰方式
懒惰方式：即检查发现如果已加载了就不再加载，直接返回已经加载的类，相当于"手工"去检查内存中是否已加载了某个类。
                .newInstance()方法，会利用默认构造器创建类实例
目前问我的主要是问反射的作用、类加载机制、反射在哪些地方用到

网络编程、数组自己看下课程笔记,几乎不会问

jdbc你自己看下增删改查的代码理论

冒泡排序、选择排序、快速排序(三种可能让你手写伪代码,其中一个忘记就说自己只记得另外两个了,看你上次自己看到代码)
参考博客:https://blog.csdn.net/qq_20198973/article/details/79679956

java设计模式总结:
总结:http://www.bjpowernode.com/tutorial_baseinterviewquestions/240.html
参考:https://www.cnblogs.com/chengxuyuanxiaoyang/p/13359306.html

java数据结构、集合、多线程、反射、设计模式、jvm和垃圾回收
几种排序(冒泡排序、选择排序、快速排序)、
面向对象:
1.接口和抽象类的区别:
1).抽象类只能继承一次，但是可以实现多个接口
2).接口和抽象类必须实现其中所有的方法，抽象类中如果有未实现的抽象方法，那么子类也需要定义为抽象类。抽象类中可以有非抽象的方法
3).接口中的变量必须用 public static final 修饰，并且需要给出初始值。所以实现类不能重新定义，也不能改变其值。
4).接口中的方法默认是 public abstract，也只能是这个类型。不能是 static，接口中的方法也不允许子类覆写，抽象类中允许有static 的方法

2.方法重载和重写的区别
参考:https://www.cnblogs.com/constantwang/p/11141566.html

3.string builder和string buffer的区别?
1).StringBuffer（线程安全的）,StringBuilder（非线程安全）
2).运算速度比较（通常情况下）：StringBuilder > StringBuffer

SSM五大组件:
1).前端处理器 DispatcherServlet
2).映射处理器 HandlerMapping
3).业务处理控制器 Controller
4).控制器返回的视图和模型的对象 ModelAndView
5).视图解析器 ViewResolver




























